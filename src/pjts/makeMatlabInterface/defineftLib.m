%% About defineftLib.m
% This file defines the MATLAB interface to the library |ftLib|.
%
% Commented sections represent C++ functionality that MATLAB cannot automatically define. To include
% functionality, uncomment a section and provide values for <SHAPE>, <DIRECTION>, etc. For more
% information, see helpview(fullfile(docroot,'matlab','helptargets.map'),'cpp_define_interface') to "Define MATLAB Interface for C++ Library".



%% Setup
% Do not edit this setup section.
function libDef = defineftLib()
libDef = clibgen.LibraryDefinition("ftLibData.xml");

%% OutputFolder and Libraries 
libDef.OutputFolder = "D:\matlabDLL";
libDef.Libraries = "libmpsse.lib";

%% C++ class |typedef void* PVOID| with MATLAB name |clib.ftLib.PVOID| 
addOpaqueType(libDef, "typedef void* PVOID", "MATLABName", "clib.ftLib.PVOID", ...
    "Description", "clib.ftLib.PVOID    C++ opaque type."); % Modify help description values as needed.

%% C++ class |_ft_device_list_info_node| with MATLAB name |clib.ftLib.FT_DEVICE_LIST_INFO_NODE| 
FT_DEVICE_LIST_INFO_NODEDefinition = addClass(libDef, "_ft_device_list_info_node", "MATLABName", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE", ...
    "Description", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE    Representation of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ class constructor for C++ class |_ft_device_list_info_node| 
% C++ Signature: _ft_device_list_info_node::_ft_device_list_info_node(_ft_device_list_info_node const & input1)

FT_DEVICE_LIST_INFO_NODEConstructor1Definition = addConstructor(FT_DEVICE_LIST_INFO_NODEDefinition, ...
    "_ft_device_list_info_node::_ft_device_list_info_node(_ft_device_list_info_node const & input1)", ...
    "Description", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE Constructor of C++ class _ft_device_list_info_node."); % Modify help description values as needed.
defineArgument(FT_DEVICE_LIST_INFO_NODEConstructor1Definition, "input1", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE", "input");
validate(FT_DEVICE_LIST_INFO_NODEConstructor1Definition);

%% C++ class constructor for C++ class |_ft_device_list_info_node| 
% C++ Signature: _ft_device_list_info_node::_ft_device_list_info_node()

FT_DEVICE_LIST_INFO_NODEConstructor2Definition = addConstructor(FT_DEVICE_LIST_INFO_NODEDefinition, ...
    "_ft_device_list_info_node::_ft_device_list_info_node()", ...
    "Description", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE Constructor of C++ class _ft_device_list_info_node."); % Modify help description values as needed.
validate(FT_DEVICE_LIST_INFO_NODEConstructor2Definition);

%% C++ class public data member |Flags| for C++ class |_ft_device_list_info_node| 
% C++ Signature: ULONG _ft_device_list_info_node::Flags

addProperty(FT_DEVICE_LIST_INFO_NODEDefinition, "Flags", "uint32", ...
    "Description", "uint32    Data member of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ class public data member |Type| for C++ class |_ft_device_list_info_node| 
% C++ Signature: ULONG _ft_device_list_info_node::Type

addProperty(FT_DEVICE_LIST_INFO_NODEDefinition, "Type", "uint32", ...
    "Description", "uint32    Data member of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ class public data member |ID| for C++ class |_ft_device_list_info_node| 
% C++ Signature: ULONG _ft_device_list_info_node::ID

addProperty(FT_DEVICE_LIST_INFO_NODEDefinition, "ID", "uint32", ...
    "Description", "uint32    Data member of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ class public data member |LocId| for C++ class |_ft_device_list_info_node| 
% C++ Signature: DWORD _ft_device_list_info_node::LocId

addProperty(FT_DEVICE_LIST_INFO_NODEDefinition, "LocId", "uint32", ...
    "Description", "uint32    Data member of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ class public data member |SerialNumber| for C++ class |_ft_device_list_info_node| 
% C++ Signature: char [16] _ft_device_list_info_node::SerialNumber

addProperty(FT_DEVICE_LIST_INFO_NODEDefinition, "SerialNumber", "clib.array.ftLib.Char", [16], ... % <MLTYPE> can be "clib.array.ftLib.Char","int8","string", or "char"
    "Description", "clib.array.ftLib.Char    Data member of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ class public data member |Description| for C++ class |_ft_device_list_info_node| 
% C++ Signature: char [64] _ft_device_list_info_node::Description

addProperty(FT_DEVICE_LIST_INFO_NODEDefinition, "Description", "clib.array.ftLib.Char", [64], ... % <MLTYPE> can be "clib.array.ftLib.Char","int8","string", or "char"
    "Description", "clib.array.ftLib.Char    Data member of C++ class _ft_device_list_info_node."); % Modify help description values as needed.

%% C++ enumeration |I2C_ClockRate_t| with MATLAB name |clib.ftLib.I2C_CLOCKRATE| 
addEnumeration(libDef, "I2C_ClockRate_t", "int32",...
    [...
      "I2C_CLOCK_STANDARD_MODE",...  % 100000
      "I2C_CLOCK_FAST_MODE",...  % 400000
      "I2C_CLOCK_FAST_MODE_PLUS",...  % 1000000
      "I2C_CLOCK_HIGH_SPEED_MODE",...  % 3400000
    ],...
    "MATLABName", "clib.ftLib.I2C_CLOCKRATE", ...
    "Description", "clib.ftLib.I2C_CLOCKRATE    Representation of C++ enumeration I2C_ClockRate_t."); % Modify help description values as needed.

%% C++ class |ChannelConfig_i2c| with MATLAB name |clib.ftLib.I2C_ChannelConfig| 
I2C_ChannelConfigDefinition = addClass(libDef, "ChannelConfig_i2c", "MATLABName", "clib.ftLib.I2C_ChannelConfig", ...
    "Description", "clib.ftLib.I2C_ChannelConfig    Representation of C++ class ChannelConfig_i2c."); % Modify help description values as needed.

%% C++ class constructor for C++ class |ChannelConfig_i2c| 
% C++ Signature: ChannelConfig_i2c::ChannelConfig_i2c(ChannelConfig_i2c const & input1)

I2C_ChannelConfigConstructor1Definition = addConstructor(I2C_ChannelConfigDefinition, ...
    "ChannelConfig_i2c::ChannelConfig_i2c(ChannelConfig_i2c const & input1)", ...
    "Description", "clib.ftLib.I2C_ChannelConfig Constructor of C++ class ChannelConfig_i2c."); % Modify help description values as needed.
defineArgument(I2C_ChannelConfigConstructor1Definition, "input1", "clib.ftLib.I2C_ChannelConfig", "input");
validate(I2C_ChannelConfigConstructor1Definition);

%% C++ class constructor for C++ class |ChannelConfig_i2c| 
% C++ Signature: ChannelConfig_i2c::ChannelConfig_i2c()

I2C_ChannelConfigConstructor2Definition = addConstructor(I2C_ChannelConfigDefinition, ...
    "ChannelConfig_i2c::ChannelConfig_i2c()", ...
    "Description", "clib.ftLib.I2C_ChannelConfig Constructor of C++ class ChannelConfig_i2c."); % Modify help description values as needed.
validate(I2C_ChannelConfigConstructor2Definition);

%% C++ class public data member |ClockRate| for C++ class |ChannelConfig_i2c| 
% C++ Signature: I2C_CLOCKRATE ChannelConfig_i2c::ClockRate

addProperty(I2C_ChannelConfigDefinition, "ClockRate", "clib.ftLib.I2C_CLOCKRATE", ...
    "Description", "clib.ftLib.I2C_CLOCKRATE    Data member of C++ class ChannelConfig_i2c."); % Modify help description values as needed.

%% C++ class public data member |LatencyTimer| for C++ class |ChannelConfig_i2c| 
% C++ Signature: UCHAR ChannelConfig_i2c::LatencyTimer

addProperty(I2C_ChannelConfigDefinition, "LatencyTimer", "uint8", ...
    "Description", "uint8    Data member of C++ class ChannelConfig_i2c." + newline + ...
    "There were 2 functions I2C_TurnOn/OffDivideByFive" + newline + ...
    "	ClockinghiSpeedDevice (FTC_HANDLE fthandle) in the old DLL. This function turns on the" + newline + ...
    "	divide by five for the MPSSE clock to allow the hi-speed devices FT2232H and FT4232H to" + newline + ...
    "	clock at the same rate as the FT2232D device. This allows for backward compatibility" + newline + ...
    "	NOTE: This feature is probably a per chip feature and not per device"); % Modify help description values as needed.

%% C++ class public data member |Options| for C++ class |ChannelConfig_i2c| 
% C++ Signature: DWORD ChannelConfig_i2c::Options

addProperty(I2C_ChannelConfigDefinition, "Options", "uint32", ...
    "Description", "uint32    Data member of C++ class ChannelConfig_i2c." + newline + ...
    "Required value, in milliseconds, of latency timer." + newline + ...
    "	Valid range is 2 ï¿½ 255" + newline + ...
    "	In the FT8U232AM and FT8U245AM devices, the receive buffer timeout that is used to flush" + newline + ...
    "	remaining data from the receive buffer was fixed at 16 ms. In all other FTDI devices, this" + newline + ...
    "	timeout is programmable and can be set at 1 ms intervals between 2ms and 255 ms.  This" + newline + ...
    "	allows the device to be better optimized for protocols requiring faster response times from" + newline + ...
    "	short data packets" + newline + ...
    "	NOTE: This feature is probably a per chip feature and not per device"); % Modify help description values as needed.

%% C++ class public data member |Pin| for C++ class |ChannelConfig_i2c| 
% C++ Signature: DWORD ChannelConfig_i2c::Pin

addProperty(I2C_ChannelConfigDefinition, "Pin", "uint32", ...
    "Description", "uint32    Data member of C++ class ChannelConfig_i2c." + newline + ...
    "This member provides a way to enable/disable features" + newline + ...
    "	specific to the protocol that are implemented in the chip" + newline + ...
    "	BIT0		: 3PhaseDataClocking - Setting this bit will turn on 3 phase data clocking for a" + newline + ...
    "			FT2232H dual hi-speed device or FT4232H quad hi-speed device. Three phase" + newline + ...
    "			data clocking, ensures the data is valid on both edges of a clock" + newline + ...
    "	BIT1		: Loopback" + newline + ...
    "	BIT2		: Clock stretching" + newline + ...
    "	BIT3 		: Enable PinState config" + newline + ...
    "	BIT4 - BIT31		: Reserved"); % Modify help description values as needed.

%% C++ class public data member |currentPinState| for C++ class |ChannelConfig_i2c| 
% C++ Signature: USHORT ChannelConfig_i2c::currentPinState

addProperty(I2C_ChannelConfigDefinition, "currentPinState", "uint16", ...
    "Description", "uint16    Data member of C++ class ChannelConfig_i2c."); % Modify help description values as needed.

%% C++ class |ChannelContext_i2c| with MATLAB name |clib.ftLib.I2C_ChannelContext| 
I2C_ChannelContextDefinition = addClass(libDef, "ChannelContext_i2c", "MATLABName", "clib.ftLib.I2C_ChannelContext", ...
    "Description", "clib.ftLib.I2C_ChannelContext    Representation of C++ class ChannelContext_i2c."); % Modify help description values as needed.

%% C++ class constructor for C++ class |ChannelContext_i2c| 
% C++ Signature: ChannelContext_i2c::ChannelContext_i2c(ChannelContext_i2c const & input1)

I2C_ChannelContextConstructor1Definition = addConstructor(I2C_ChannelContextDefinition, ...
    "ChannelContext_i2c::ChannelContext_i2c(ChannelContext_i2c const & input1)", ...
    "Description", "clib.ftLib.I2C_ChannelContext Constructor of C++ class ChannelContext_i2c."); % Modify help description values as needed.
defineArgument(I2C_ChannelContextConstructor1Definition, "input1", "clib.ftLib.I2C_ChannelContext", "input");
validate(I2C_ChannelContextConstructor1Definition);

%% C++ class constructor for C++ class |ChannelContext_i2c| 
% C++ Signature: ChannelContext_i2c::ChannelContext_i2c()

I2C_ChannelContextConstructor2Definition = addConstructor(I2C_ChannelContextDefinition, ...
    "ChannelContext_i2c::ChannelContext_i2c()", ...
    "Description", "clib.ftLib.I2C_ChannelContext Constructor of C++ class ChannelContext_i2c."); % Modify help description values as needed.
validate(I2C_ChannelContextConstructor2Definition);

%% C++ class public data member |config| for C++ class |ChannelContext_i2c| 
% C++ Signature: I2C_ChannelConfig ChannelContext_i2c::config

addProperty(I2C_ChannelContextDefinition, "config", "clib.ftLib.I2C_ChannelConfig", ...
    "Description", "clib.ftLib.I2C_ChannelConfig    Data member of C++ class ChannelContext_i2c."); % Modify help description values as needed.

%% C++ class public data member |next| for C++ class |ChannelContext_i2c| 
% C++ Signature: ChannelContext_i2c * ChannelContext_i2c::next

%addProperty(I2C_ChannelContextDefinition, "next", "clib.ftLib.I2C_ChannelContext", <SHAPE>, ... % <MLTYPE> can be "clib.ftLib.I2C_ChannelContext", or "clib.array.ftLib.I2C_ChannelContext"
%    "Description", "clib.ftLib.I2C_ChannelContext    Data member of C++ class ChannelContext_i2c."); % Modify help description values as needed.

%% C++ class |ChannelConfig_spi| with MATLAB name |clib.ftLib.SPI_ChannelConfig| 
SPI_ChannelConfigDefinition = addClass(libDef, "ChannelConfig_spi", "MATLABName", "clib.ftLib.SPI_ChannelConfig", ...
    "Description", "clib.ftLib.SPI_ChannelConfig    Representation of C++ class ChannelConfig_spi."); % Modify help description values as needed.

%% C++ class constructor for C++ class |ChannelConfig_spi| 
% C++ Signature: ChannelConfig_spi::ChannelConfig_spi(ChannelConfig_spi const & input1)

SPI_ChannelConfigConstructor1Definition = addConstructor(SPI_ChannelConfigDefinition, ...
    "ChannelConfig_spi::ChannelConfig_spi(ChannelConfig_spi const & input1)", ...
    "Description", "clib.ftLib.SPI_ChannelConfig Constructor of C++ class ChannelConfig_spi."); % Modify help description values as needed.
defineArgument(SPI_ChannelConfigConstructor1Definition, "input1", "clib.ftLib.SPI_ChannelConfig", "input");
validate(SPI_ChannelConfigConstructor1Definition);

%% C++ class constructor for C++ class |ChannelConfig_spi| 
% C++ Signature: ChannelConfig_spi::ChannelConfig_spi()

SPI_ChannelConfigConstructor2Definition = addConstructor(SPI_ChannelConfigDefinition, ...
    "ChannelConfig_spi::ChannelConfig_spi()", ...
    "Description", "clib.ftLib.SPI_ChannelConfig Constructor of C++ class ChannelConfig_spi."); % Modify help description values as needed.
validate(SPI_ChannelConfigConstructor2Definition);

%% C++ class public data member |ClockRate| for C++ class |ChannelConfig_spi| 
% C++ Signature: DWORD ChannelConfig_spi::ClockRate

addProperty(SPI_ChannelConfigDefinition, "ClockRate", "uint32", ...
    "Description", "uint32    Data member of C++ class ChannelConfig_spi."); % Modify help description values as needed.

%% C++ class public data member |LatencyTimer| for C++ class |ChannelConfig_spi| 
% C++ Signature: UCHAR ChannelConfig_spi::LatencyTimer

addProperty(SPI_ChannelConfigDefinition, "LatencyTimer", "uint8", ...
    "Description", "uint8    Data member of C++ class ChannelConfig_spi."); % Modify help description values as needed.

%% C++ class public data member |configOptions| for C++ class |ChannelConfig_spi| 
% C++ Signature: DWORD ChannelConfig_spi::configOptions

addProperty(SPI_ChannelConfigDefinition, "configOptions", "uint32", ...
    "Description", "uint32    Data member of C++ class ChannelConfig_spi."); % Modify help description values as needed.

%% C++ class public data member |Pin| for C++ class |ChannelConfig_spi| 
% C++ Signature: DWORD ChannelConfig_spi::Pin

addProperty(SPI_ChannelConfigDefinition, "Pin", "uint32", ...
    "Description", "uint32    Data member of C++ class ChannelConfig_spi."); % Modify help description values as needed.

%% C++ class public data member |currentPinState| for C++ class |ChannelConfig_spi| 
% C++ Signature: USHORT ChannelConfig_spi::currentPinState

addProperty(SPI_ChannelConfigDefinition, "currentPinState", "uint16", ...
    "Description", "uint16    Data member of C++ class ChannelConfig_spi."); % Modify help description values as needed.

%% C++ class |ChannelContext_spi| with MATLAB name |clib.ftLib.SPI_ChannelContext| 
SPI_ChannelContextDefinition = addClass(libDef, "ChannelContext_spi", "MATLABName", "clib.ftLib.SPI_ChannelContext", ...
    "Description", "clib.ftLib.SPI_ChannelContext    Representation of C++ class ChannelContext_spi."); % Modify help description values as needed.

%% C++ class constructor for C++ class |ChannelContext_spi| 
% C++ Signature: ChannelContext_spi::ChannelContext_spi(ChannelContext_spi const & input1)

SPI_ChannelContextConstructor1Definition = addConstructor(SPI_ChannelContextDefinition, ...
    "ChannelContext_spi::ChannelContext_spi(ChannelContext_spi const & input1)", ...
    "Description", "clib.ftLib.SPI_ChannelContext Constructor of C++ class ChannelContext_spi."); % Modify help description values as needed.
defineArgument(SPI_ChannelContextConstructor1Definition, "input1", "clib.ftLib.SPI_ChannelContext", "input");
validate(SPI_ChannelContextConstructor1Definition);

%% C++ class constructor for C++ class |ChannelContext_spi| 
% C++ Signature: ChannelContext_spi::ChannelContext_spi()

SPI_ChannelContextConstructor2Definition = addConstructor(SPI_ChannelContextDefinition, ...
    "ChannelContext_spi::ChannelContext_spi()", ...
    "Description", "clib.ftLib.SPI_ChannelContext Constructor of C++ class ChannelContext_spi."); % Modify help description values as needed.
validate(SPI_ChannelContextConstructor2Definition);

%% C++ class public data member |config| for C++ class |ChannelContext_spi| 
% C++ Signature: SPI_ChannelConfig ChannelContext_spi::config

addProperty(SPI_ChannelContextDefinition, "config", "clib.ftLib.SPI_ChannelConfig", ...
    "Description", "clib.ftLib.SPI_ChannelConfig    Data member of C++ class ChannelContext_spi."); % Modify help description values as needed.

%% C++ class public data member |next| for C++ class |ChannelContext_spi| 
% C++ Signature: ChannelContext_spi * ChannelContext_spi::next

%addProperty(SPI_ChannelContextDefinition, "next", "clib.ftLib.SPI_ChannelContext", <SHAPE>, ... % <MLTYPE> can be "clib.ftLib.SPI_ChannelContext", or "clib.array.ftLib.SPI_ChannelContext"
%    "Description", "clib.ftLib.SPI_ChannelContext    Data member of C++ class ChannelContext_spi."); % Modify help description values as needed.

%% C++ function |Init_libMPSSE| with MATLAB name |clib.ftLib.Init_libMPSSE|
% C++ Signature: void Init_libMPSSE()

Init_libMPSSEDefinition = addFunction(libDef, ...
    "void Init_libMPSSE()", ...
    "MATLABName", "clib.ftLib.Init_libMPSSE", ...
    "Description", "clib.ftLib.Init_libMPSSE Representation of C++ function Init_libMPSSE." + newline + ...
    "This function initializes libMPSSE", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "This function is called once when the library is loaded. It initializes all the modules in the" + newline + ...
    " library. This function initializes all the variables and data structures that are required to be" + newline + ...
    " initialized once only during loading."); % Modify help description values as needed.
validate(Init_libMPSSEDefinition);

%% C++ function |Cleanup_libMPSSE| with MATLAB name |clib.ftLib.Cleanup_libMPSSE|
% C++ Signature: void Cleanup_libMPSSE()

Cleanup_libMPSSEDefinition = addFunction(libDef, ...
    "void Cleanup_libMPSSE()", ...
    "MATLABName", "clib.ftLib.Cleanup_libMPSSE", ...
    "Description", "clib.ftLib.Cleanup_libMPSSE Representation of C++ function Cleanup_libMPSSE." + newline + ...
    "Cleans up the module before unloading", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "This function frees all the resources that were allocated during initialization. It should be called" + newline + ...
    " by the OS to ensure that the module exits gracefully"); % Modify help description values as needed.
validate(Cleanup_libMPSSEDefinition);

%% C++ function |I2C_GetNumChannels| with MATLAB name |clib.ftLib.I2C_GetNumChannels|
% C++ Signature: FT_STATUS I2C_GetNumChannels(DWORD * numChannels)

%I2C_GetNumChannelsDefinition = addFunction(libDef, ...
%    "FT_STATUS I2C_GetNumChannels(DWORD * numChannels)", ...
%    "MATLABName", "clib.ftLib.I2C_GetNumChannels", ...
%    "Description", "clib.ftLib.I2C_GetNumChannels Representation of C++ function I2C_GetNumChannels." + newline + ...
%    "Gets the number of I2C channels connected to the host", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function gets the number of I2C channels that are connected to the host system" + newline + ...
%    " The number of ports available in each of these chips are different."); % Modify help description values as needed.
%defineArgument(I2C_GetNumChannelsDefinition, "numChannels", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] *numChannels Pointer to variable in which the no of channels will be returned"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineOutput(I2C_GetNumChannelsDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(I2C_GetNumChannelsDefinition);

%% C++ function |I2C_GetChannelInfo| with MATLAB name |clib.ftLib.I2C_GetChannelInfo|
% C++ Signature: FT_STATUS I2C_GetChannelInfo(DWORD index,FT_DEVICE_LIST_INFO_NODE * chanInfo)

%I2C_GetChannelInfoDefinition = addFunction(libDef, ...
%    "FT_STATUS I2C_GetChannelInfo(DWORD index,FT_DEVICE_LIST_INFO_NODE * chanInfo)", ...
%    "MATLABName", "clib.ftLib.I2C_GetChannelInfo", ...
%    "Description", "clib.ftLib.I2C_GetChannelInfo Representation of C++ function I2C_GetChannelInfo." + newline + ...
%    "Provides information about channel", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function takes a channel index (valid values are from 1 to the value returned by" + newline + ...
%    " I2C_GetNumChannels) and provides information about the channel in the form of a populated" + newline + ...
%    " ChannelInfo structure."); % Modify help description values as needed.
%defineArgument(I2C_GetChannelInfoDefinition, "index", "uint32", "Description", "[in] index Index of the channel");
%defineArgument(I2C_GetChannelInfoDefinition, "chanInfo", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE", "input", <SHAPE>, "Description", "[out] chanInfo Pointer to FT_DEVICE_LIST_INFO_NODE structure(see D2XX  *			  Programmer's Guide)"); % <MLTYPE> can be "clib.ftLib.FT_DEVICE_LIST_INFO_NODE", or "clib.array.ftLib.FT_DEVICE_LIST_INFO_NODE"
%defineOutput(I2C_GetChannelInfoDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)" + newline + ...
%    "\note  The channel ID can be determined by the user from the last digit of the location ID");
%validate(I2C_GetChannelInfoDefinition);

%% C++ function |I2C_OpenChannel| with MATLAB name |clib.ftLib.I2C_OpenChannel|
% C++ Signature: FT_STATUS I2C_OpenChannel(DWORD index,FT_HANDLE * handle)

I2C_OpenChannelDefinition = addFunction(libDef, ...
    "FT_STATUS I2C_OpenChannel(DWORD index,FT_HANDLE * handle)", ...
    "MATLABName", "clib.ftLib.I2C_OpenChannel", ...
    "Description", "clib.ftLib.I2C_OpenChannel Representation of C++ function I2C_OpenChannel." + newline + ...
    "Opens a channel and returns a handle to it", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "This function opens the indexed channel and returns a handle to it"); % Modify help description values as needed.
defineArgument(I2C_OpenChannelDefinition, "index", "uint32", "Description", "[in] index Index of the channel");
defineArgument(I2C_OpenChannelDefinition, "handle", "clib.ftLib.PVOID", "output", 1, "Description", "[out] handle Pointer to the handle of the opened channel");
defineOutput(I2C_OpenChannelDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
validate(I2C_OpenChannelDefinition);

%% C++ function |I2C_InitChannel| with MATLAB name |clib.ftLib.I2C_InitChannel|
% C++ Signature: FT_STATUS I2C_InitChannel(FT_HANDLE handle,I2C_ChannelConfig * config)

%I2C_InitChannelDefinition = addFunction(libDef, ...
%    "FT_STATUS I2C_InitChannel(FT_HANDLE handle,I2C_ChannelConfig * config)", ...
%    "MATLABName", "clib.ftLib.I2C_InitChannel", ...
%    "Description", "clib.ftLib.I2C_InitChannel Representation of C++ function I2C_InitChannel." + newline + ...
%    "Initializes a channel", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function initializes the channel and the communication parameters associated with it"); % Modify help description values as needed.
%defineArgument(I2C_InitChannelDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(I2C_InitChannelDefinition, "config", "clib.ftLib.I2C_ChannelConfig", "input", <SHAPE>, "Description", "[out] config Pointer to I2C_ChannelConfig structure(memory to be allocated by caller)"); % <MLTYPE> can be "clib.ftLib.I2C_ChannelConfig", or "clib.array.ftLib.I2C_ChannelConfig"
%defineOutput(I2C_InitChannelDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(I2C_InitChannelDefinition);

%% C++ function |I2C_CloseChannel| with MATLAB name |clib.ftLib.I2C_CloseChannel|
% C++ Signature: FT_STATUS I2C_CloseChannel(FT_HANDLE handle)

I2C_CloseChannelDefinition = addFunction(libDef, ...
    "FT_STATUS I2C_CloseChannel(FT_HANDLE handle)", ...
    "MATLABName", "clib.ftLib.I2C_CloseChannel", ...
    "Description", "clib.ftLib.I2C_CloseChannel Representation of C++ function I2C_CloseChannel." + newline + ...
    "Closes a channel", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "Closes a channel and frees all resources that were used by it"); % Modify help description values as needed.
defineArgument(I2C_CloseChannelDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
defineOutput(I2C_CloseChannelDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
validate(I2C_CloseChannelDefinition);

%% C++ function |I2C_DeviceRead| with MATLAB name |clib.ftLib.I2C_DeviceRead|
% C++ Signature: FT_STATUS I2C_DeviceRead(FT_HANDLE handle,UCHAR deviceAddress,DWORD sizeToTransfer,UCHAR * buffer,LPDWORD sizeTransfered,DWORD options)

%I2C_DeviceReadDefinition = addFunction(libDef, ...
%    "FT_STATUS I2C_DeviceRead(FT_HANDLE handle,UCHAR deviceAddress,DWORD sizeToTransfer,UCHAR * buffer,LPDWORD sizeTransfered,DWORD options)", ...
%    "MATLABName", "clib.ftLib.I2C_DeviceRead", ...
%    "Description", "clib.ftLib.I2C_DeviceRead Representation of C++ function I2C_DeviceRead." + newline + ...
%    "Reads data from I2C slave", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function reads the specified number of bytes from an addressed I2C slave"); % Modify help description values as needed.
%defineArgument(I2C_DeviceReadDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(I2C_DeviceReadDefinition, "deviceAddress", "uint8", "Description", "[in] deviceAddress Address of the I2C slave");
%defineArgument(I2C_DeviceReadDefinition, "sizeToTransfer", "uint32", "Description", "[in] sizeToTransfer Number of bytes to be read");
%defineArgument(I2C_DeviceReadDefinition, "buffer", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[out] buffer Pointer to the buffer where data is to be read"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineArgument(I2C_DeviceReadDefinition, "sizeTransfered", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] sizeTransferred Pointer to variable containing the number of bytes read"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineArgument(I2C_DeviceReadDefinition, "options", "uint32", "Description", "[in] options This parameter specifies data transfer options. Namely, if a start/stop bits" + newline + ...
%    "*			are required, if the transfer should continue or stop if device nAcks, etc");
%defineOutput(I2C_DeviceReadDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(I2C_DeviceReadDefinition);

%% C++ function |I2C_DeviceWrite| with MATLAB name |clib.ftLib.I2C_DeviceWrite|
% C++ Signature: FT_STATUS I2C_DeviceWrite(FT_HANDLE handle,UCHAR deviceAddress,DWORD sizeToTransfer,UCHAR * buffer,LPDWORD sizeTransfered,DWORD options)

%I2C_DeviceWriteDefinition = addFunction(libDef, ...
%    "FT_STATUS I2C_DeviceWrite(FT_HANDLE handle,UCHAR deviceAddress,DWORD sizeToTransfer,UCHAR * buffer,LPDWORD sizeTransfered,DWORD options)", ...
%    "MATLABName", "clib.ftLib.I2C_DeviceWrite", ...
%    "Description", "clib.ftLib.I2C_DeviceWrite Representation of C++ function I2C_DeviceWrite." + newline + ...
%    "Writes data from I2C slave", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function writes the specified number of bytes from an addressed I2C slave"); % Modify help description values as needed.
%defineArgument(I2C_DeviceWriteDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(I2C_DeviceWriteDefinition, "deviceAddress", "uint8", "Description", "[in] deviceAddress Address of the I2C slave");
%defineArgument(I2C_DeviceWriteDefinition, "sizeToTransfer", "uint32", "Description", "[in] sizeToTransfer Number of bytes to be written");
%defineArgument(I2C_DeviceWriteDefinition, "buffer", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[out] buffer Pointer to the buffer from where data is to be written"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineArgument(I2C_DeviceWriteDefinition, "sizeTransfered", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] sizeTransferred Pointer to variable containing the number of bytes written"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineArgument(I2C_DeviceWriteDefinition, "options", "uint32", "Description", "[in] options This parameter specifies data transfer options. Namely if a start/stop bits" + newline + ...
%    "*			are required, if the transfer should continue or stop if device nAcks, etc");
%defineOutput(I2C_DeviceWriteDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(I2C_DeviceWriteDefinition);

%% C++ function |I2C_GetDeviceID| with MATLAB name |clib.ftLib.I2C_GetDeviceID|
% C++ Signature: FT_STATUS I2C_GetDeviceID(FT_HANDLE handle,UCHAR deviceAddress,UCHAR * deviceID)

%I2C_GetDeviceIDDefinition = addFunction(libDef, ...
%    "FT_STATUS I2C_GetDeviceID(FT_HANDLE handle,UCHAR deviceAddress,UCHAR * deviceID)", ...
%    "MATLABName", "clib.ftLib.I2C_GetDeviceID", ...
%    "Description", "clib.ftLib.I2C_GetDeviceID Representation of C++ function I2C_GetDeviceID." + newline + ...
%    "Get the I2C device ID", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function retrieves the I2C device ID. It may not be enabled in the library" + newline + ...
%    " depending on build configuration. If it is not enabled then it will return" + newline + ...
%    " FT_NOT_SUPPORTED."); % Modify help description values as needed.
%defineArgument(I2C_GetDeviceIDDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(I2C_GetDeviceIDDefinition, "deviceAddress", "uint8", "Description", "[in] deviceAddress Address of the I2C slave");
%defineArgument(I2C_GetDeviceIDDefinition, "deviceID", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[out] deviceID Address of memory where the 3byte I2C device ID will be stored"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineOutput(I2C_GetDeviceIDDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(I2C_GetDeviceIDDefinition);

%% C++ function |FT_WriteGPIO| with MATLAB name |clib.ftLib.FT_WriteGPIO|
% C++ Signature: FT_STATUS FT_WriteGPIO(FT_HANDLE handle,UCHAR dir,UCHAR value)

FT_WriteGPIODefinition = addFunction(libDef, ...
    "FT_STATUS FT_WriteGPIO(FT_HANDLE handle,UCHAR dir,UCHAR value)", ...
    "MATLABName", "clib.ftLib.FT_WriteGPIO", ...
    "Description", "clib.ftLib.FT_WriteGPIO Representation of C++ function FT_WriteGPIO." + newline + ...
    "Writes to the 8 GPIO lines", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "Writes to the 8 GPIO lines associated with the high byte of the MPSSE channel"); % Modify help description values as needed.
defineArgument(FT_WriteGPIODefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
defineArgument(FT_WriteGPIODefinition, "dir", "uint8", "Description", "[in] dir The direction of the 8 lines. 0 for in and 1 for out");
defineArgument(FT_WriteGPIODefinition, "value", "uint8", "Description", "[in] value Output state of the 8 GPIO lines");
defineOutput(FT_WriteGPIODefinition, "RetVal", "uint32", "Description", "status");
validate(FT_WriteGPIODefinition);

%% C++ function |FT_ReadGPIO| with MATLAB name |clib.ftLib.FT_ReadGPIO|
% C++ Signature: FT_STATUS FT_ReadGPIO(FT_HANDLE handle,UCHAR * value)

%FT_ReadGPIODefinition = addFunction(libDef, ...
%    "FT_STATUS FT_ReadGPIO(FT_HANDLE handle,UCHAR * value)", ...
%    "MATLABName", "clib.ftLib.FT_ReadGPIO", ...
%    "Description", "clib.ftLib.FT_ReadGPIO Representation of C++ function FT_ReadGPIO." + newline + ...
%    "Reads from the 8 GPIO lines", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function reads the GPIO lines associated with the high byte of the MPSSE channel"); % Modify help description values as needed.
%defineArgument(FT_ReadGPIODefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(FT_ReadGPIODefinition, "value", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[out] *value Input state of the 8 GPIO lines(1 = high)"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineOutput(FT_ReadGPIODefinition, "RetVal", "uint32", "Description", "status");
%validate(FT_ReadGPIODefinition);

%% C++ function |Ver_libMPSSE| with MATLAB name |clib.ftLib.Ver_libMPSSE|
% C++ Signature: FT_STATUS Ver_libMPSSE(LPDWORD libmpsse,LPDWORD libftd2xx)

%Ver_libMPSSEDefinition = addFunction(libDef, ...
%    "FT_STATUS Ver_libMPSSE(LPDWORD libmpsse,LPDWORD libftd2xx)", ...
%    "MATLABName", "clib.ftLib.Ver_libMPSSE", ...
%    "Description", "clib.ftLib.Ver_libMPSSE Representation of C++ function Ver_libMPSSE." + newline + ...
%    "Version Number Function", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "Returns libMPSSE and libFTD2XX version number"); % Modify help description values as needed.
%defineArgument(Ver_libMPSSEDefinition, "libmpsse", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out]  *libmpsse	MPSSE version number is returned"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineArgument(Ver_libMPSSEDefinition, "libftd2xx", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out]  *libftd2xx	D2XX version number is returned"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineOutput(Ver_libMPSSEDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(Ver_libMPSSEDefinition);

%% C++ function |SPI_GetNumChannels| with MATLAB name |clib.ftLib.SPI_GetNumChannels|
% C++ Signature: FT_STATUS SPI_GetNumChannels(DWORD * numChannels)

%SPI_GetNumChannelsDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_GetNumChannels(DWORD * numChannels)", ...
%    "MATLABName", "clib.ftLib.SPI_GetNumChannels", ...
%    "Description", "clib.ftLib.SPI_GetNumChannels Representation of C++ function SPI_GetNumChannels." + newline + ...
%    "Gets the number of SPI channels connected to the host", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function gets the number of SPI channels that are connected to the host system"); % Modify help description values as needed.
%defineArgument(SPI_GetNumChannelsDefinition, "numChannels", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] *numChannels Pointer to variable in which the no of channels will be returned"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineOutput(SPI_GetNumChannelsDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(SPI_GetNumChannelsDefinition);

%% C++ function |SPI_GetChannelInfo| with MATLAB name |clib.ftLib.SPI_GetChannelInfo|
% C++ Signature: FT_STATUS SPI_GetChannelInfo(DWORD index,FT_DEVICE_LIST_INFO_NODE * chanInfo)

%SPI_GetChannelInfoDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_GetChannelInfo(DWORD index,FT_DEVICE_LIST_INFO_NODE * chanInfo)", ...
%    "MATLABName", "clib.ftLib.SPI_GetChannelInfo", ...
%    "Description", "clib.ftLib.SPI_GetChannelInfo Representation of C++ function SPI_GetChannelInfo." + newline + ...
%    "Provides information about channel", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function takes a channel index (valid values are from 0 to the value returned by" + newline + ...
%    " SPI_GetChannelInfo -1) and provides information about the channel in the form of a" + newline + ...
%    " populated ChannelInfo structure."); % Modify help description values as needed.
%defineArgument(SPI_GetChannelInfoDefinition, "index", "uint32", "Description", "[in] index Index of the channel");
%defineArgument(SPI_GetChannelInfoDefinition, "chanInfo", "clib.ftLib.FT_DEVICE_LIST_INFO_NODE", "input", <SHAPE>, "Description", "[out] chanInfo Pointer to FT_DEVICE_LIST_INFO_NODE structure(see D2XX Programmer's Guide)"); % <MLTYPE> can be "clib.ftLib.FT_DEVICE_LIST_INFO_NODE", or "clib.array.ftLib.FT_DEVICE_LIST_INFO_NODE"
%defineOutput(SPI_GetChannelInfoDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)" + newline + ...
%    "\note  The channel ID can be determined by the user from the last digit of the location ID");
%validate(SPI_GetChannelInfoDefinition);

%% C++ function |SPI_OpenChannel| with MATLAB name |clib.ftLib.SPI_OpenChannel|
% C++ Signature: FT_STATUS SPI_OpenChannel(DWORD index,FT_HANDLE * handle)

SPI_OpenChannelDefinition = addFunction(libDef, ...
    "FT_STATUS SPI_OpenChannel(DWORD index,FT_HANDLE * handle)", ...
    "MATLABName", "clib.ftLib.SPI_OpenChannel", ...
    "Description", "clib.ftLib.SPI_OpenChannel Representation of C++ function SPI_OpenChannel." + newline + ...
    "Opens a channel and returns a handle to it", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "This function opens the indexed channel and returns a handle to it"); % Modify help description values as needed.
defineArgument(SPI_OpenChannelDefinition, "index", "uint32", "Description", "[in] index Index of the channel");
defineArgument(SPI_OpenChannelDefinition, "handle", "clib.ftLib.PVOID", "output", 1, "Description", "[out] handle Pointer to the handle of the opened channel");
defineOutput(SPI_OpenChannelDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
validate(SPI_OpenChannelDefinition);

%% C++ function |SPI_InitChannel| with MATLAB name |clib.ftLib.SPI_InitChannel|
% C++ Signature: FT_STATUS SPI_InitChannel(FT_HANDLE handle,SPI_ChannelConfig * config)

%SPI_InitChannelDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_InitChannel(FT_HANDLE handle,SPI_ChannelConfig * config)", ...
%    "MATLABName", "clib.ftLib.SPI_InitChannel", ...
%    "Description", "clib.ftLib.SPI_InitChannel Representation of C++ function SPI_InitChannel." + newline + ...
%    "Initializes a channel", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function initializes the channel and the communication parameters associated with it"); % Modify help description values as needed.
%defineArgument(SPI_InitChannelDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(SPI_InitChannelDefinition, "config", "clib.ftLib.SPI_ChannelConfig", "input", <SHAPE>, "Description", "[out] config Pointer to SPI_ChannelConfig structure(memory to be allocated by caller)"); % <MLTYPE> can be "clib.ftLib.SPI_ChannelConfig", or "clib.array.ftLib.SPI_ChannelConfig"
%defineOutput(SPI_InitChannelDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(SPI_InitChannelDefinition);

%% C++ function |SPI_CloseChannel| with MATLAB name |clib.ftLib.SPI_CloseChannel|
% C++ Signature: FT_STATUS SPI_CloseChannel(FT_HANDLE handle)

SPI_CloseChannelDefinition = addFunction(libDef, ...
    "FT_STATUS SPI_CloseChannel(FT_HANDLE handle)", ...
    "MATLABName", "clib.ftLib.SPI_CloseChannel", ...
    "Description", "clib.ftLib.SPI_CloseChannel Representation of C++ function SPI_CloseChannel." + newline + ...
    "Closes a channel", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "Closes a channel and frees all resources that were used by it"); % Modify help description values as needed.
defineArgument(SPI_CloseChannelDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
defineOutput(SPI_CloseChannelDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
validate(SPI_CloseChannelDefinition);

%% C++ function |SPI_Read| with MATLAB name |clib.ftLib.SPI_Read|
% C++ Signature: FT_STATUS SPI_Read(FT_HANDLE handle,UCHAR * buffer,DWORD sizeToTransfer,LPDWORD sizeTransfered,DWORD options)

%SPI_ReadDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_Read(FT_HANDLE handle,UCHAR * buffer,DWORD sizeToTransfer,LPDWORD sizeTransfered,DWORD options)", ...
%    "MATLABName", "clib.ftLib.SPI_Read", ...
%    "Description", "clib.ftLib.SPI_Read Representation of C++ function SPI_Read." + newline + ...
%    "Reads data from a SPI slave device", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function reads the specified number of bits or bytes from the SPI device"); % Modify help description values as needed.
%defineArgument(SPI_ReadDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(SPI_ReadDefinition, "buffer", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[in] *buffer Pointer to buffer to where data will be read to"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineArgument(SPI_ReadDefinition, "sizeToTransfer", "uint32", "Description", "[in] sizeToTransfer Size of data to be transfered");
%defineArgument(SPI_ReadDefinition, "sizeTransfered", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] sizeTransfered Pointer to variable containing the size of data" + newline + ...
%    "*			that got transferred"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineArgument(SPI_ReadDefinition, "options", "uint32", "Description", "[in] transferOptions This parameter specifies data transfer options" + newline + ...
%    "*				if BIT0 is 0 then size is in bytes, otherwise in bits" + newline + ...
%    "*				if BIT1 is 1 then CHIP_SELECT line will be enables at start of transfer" + newline + ...
%    "*				if BIT2 is 1 then CHIP_SELECT line will be disabled at end of transfer");
%defineOutput(SPI_ReadDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(SPI_ReadDefinition);

%% C++ function |SPI_Write| with MATLAB name |clib.ftLib.SPI_Write|
% C++ Signature: FT_STATUS SPI_Write(FT_HANDLE handle,UCHAR * buffer,DWORD sizeToTransfer,LPDWORD sizeTransfered,DWORD options)

%SPI_WriteDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_Write(FT_HANDLE handle,UCHAR * buffer,DWORD sizeToTransfer,LPDWORD sizeTransfered,DWORD options)", ...
%    "MATLABName", "clib.ftLib.SPI_Write", ...
%    "Description", "clib.ftLib.SPI_Write Representation of C++ function SPI_Write." + newline + ...
%    "Writes data to a SPI slave device", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function writes the specified number of bits or bytes to the SPI device"); % Modify help description values as needed.
%defineArgument(SPI_WriteDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(SPI_WriteDefinition, "buffer", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[in] *buffer Pointer to buffer from containing the data"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineArgument(SPI_WriteDefinition, "sizeToTransfer", "uint32", "Description", "[in] sizeToTransfer Size of data to be transfered");
%defineArgument(SPI_WriteDefinition, "sizeTransfered", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] sizeTransfered Pointer to variable containing the size of data" + newline + ...
%    "*			that got transferred"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineArgument(SPI_WriteDefinition, "options", "uint32", "Description", "[in] transferOptions This parameter specifies data transfer options" + newline + ...
%    "*				if BIT0 is 0 then size is in bytes, otherwise in bits" + newline + ...
%    "*				if BIT1 is 1 then CHIP_SELECT line will be enables at start of transfer" + newline + ...
%    "*				if BIT2 is 1 then CHIP_SELECT line will be disabled at end of transfer");
%defineOutput(SPI_WriteDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(SPI_WriteDefinition);

%% C++ function |SPI_ReadWrite| with MATLAB name |clib.ftLib.SPI_ReadWrite|
% C++ Signature: FT_STATUS SPI_ReadWrite(FT_HANDLE handle,UCHAR * inBuffer,UCHAR * outBuffer,DWORD sizeToTransfer,LPDWORD sizeTransferred,DWORD transferOptions)

%SPI_ReadWriteDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_ReadWrite(FT_HANDLE handle,UCHAR * inBuffer,UCHAR * outBuffer,DWORD sizeToTransfer,LPDWORD sizeTransferred,DWORD transferOptions)", ...
%    "MATLABName", "clib.ftLib.SPI_ReadWrite", ...
%    "Description", "clib.ftLib.SPI_ReadWrite Representation of C++ function SPI_ReadWrite." + newline + ...
%    "Reads and writes data from/to a SPI slave device", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "This function transfers data in both directions between a SPI master and a slave. One bit is" + newline + ...
%    " clocked out and one bit is clocked in during every clock."); % Modify help description values as needed.
%defineArgument(SPI_ReadWriteDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(SPI_ReadWriteDefinition, "inBuffer", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[in] *inBuffer Pointer to buffer to which data read will be stored"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineArgument(SPI_ReadWriteDefinition, "outBuffer", "clib.array.ftLib.UnsignedChar", "input", <SHAPE>, "Description", "[in] *outBuffer Pointer to buffer that contains data to be transferred to the slave"); % <MLTYPE> can be "clib.array.ftLib.UnsignedChar", or "uint8"
%defineArgument(SPI_ReadWriteDefinition, "sizeToTransfer", "uint32", "Description", "[in] sizeToTransfer Size of data to be transferred");
%defineArgument(SPI_ReadWriteDefinition, "sizeTransferred", "clib.array.ftLib.UnsignedLong", "input", <SHAPE>, "Description", "[out] sizeTransfered Pointer to variable containing the size of data" + newline + ...
%    "*			that got transferred"); % <MLTYPE> can be "clib.array.ftLib.UnsignedLong", or "uint32"
%defineArgument(SPI_ReadWriteDefinition, "transferOptions", "uint32", "Description", "[in] transferOptions This parameter specifies data transfer options" + newline + ...
%    "*				if BIT0 is 0 then size is in bytes, otherwise in bits" + newline + ...
%    "*				if BIT1 is 1 then CHIP_SELECT line will be enables at start of transfer" + newline + ...
%    "*				if BIT2 is 1 then CHIP_SELECT line will be disabled at end of transfer");
%defineOutput(SPI_ReadWriteDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(SPI_ReadWriteDefinition);

%% C++ function |SPI_IsBusy| with MATLAB name |clib.ftLib.SPI_IsBusy|
% C++ Signature: FT_STATUS SPI_IsBusy(FT_HANDLE handle,BOOL * state)

%SPI_IsBusyDefinition = addFunction(libDef, ...
%    "FT_STATUS SPI_IsBusy(FT_HANDLE handle,BOOL * state)", ...
%    "MATLABName", "clib.ftLib.SPI_IsBusy", ...
%    "Description", "clib.ftLib.SPI_IsBusy Representation of C++ function SPI_IsBusy." + newline + ...
%    "Read the state of SPI MISO line", ...
%    "DetailedDescription", "This content is from the external library documentation." + newline + ...
%    "" + newline + ...
%    "Reads the logic state of the SPI MISO line without clocking the bus"); % Modify help description values as needed.
%defineArgument(SPI_IsBusyDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
%defineArgument(SPI_IsBusyDefinition, "state", "clib.array.ftLib.Int", "input", <SHAPE>, "Description", "[out] *state State of the line"); % <MLTYPE> can be "clib.array.ftLib.Int", or "int32"
%defineOutput(SPI_IsBusyDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
%validate(SPI_IsBusyDefinition);

%% C++ function |SPI_ChangeCS| with MATLAB name |clib.ftLib.SPI_ChangeCS|
% C++ Signature: FT_STATUS SPI_ChangeCS(FT_HANDLE handle,DWORD configOptions)

SPI_ChangeCSDefinition = addFunction(libDef, ...
    "FT_STATUS SPI_ChangeCS(FT_HANDLE handle,DWORD configOptions)", ...
    "MATLABName", "clib.ftLib.SPI_ChangeCS", ...
    "Description", "clib.ftLib.SPI_ChangeCS Representation of C++ function SPI_ChangeCS." + newline + ...
    "Changes the chip select line", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "This function changes the chip select line that is to be used to communicate to the SPI slave"); % Modify help description values as needed.
defineArgument(SPI_ChangeCSDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
defineArgument(SPI_ChangeCSDefinition, "configOptions", "uint32", "Description", "[in] configOptions Provides a way to select the chip select line & SPI mode" + newline + ...
    "*	BIT1-0=CPOL-CPHA:	00 - MODE0 - data captured on rising edge, propagated on falling" + newline + ...
    "*						01 - MODE1 - data captured on falling edge, propagated on rising" + newline + ...
    "*						10 - MODE2 - data captured on falling edge, propagated on rising" + newline + ...
    "*						11 - MODE3 - data captured on rising edge, propagated on falling" + newline + ...
    "*	BIT4-BIT2: 000 - A/B/C/D_DBUS3=ChipSelect" + newline + ...
    "*			 : 001 - A/B/C/D_DBUS4=ChipSelect" + newline + ...
    "			 : 010 - A/B/C/D_DBUS5=ChipSelect" + newline + ...
    "*			 : 011 - A/B/C/D_DBUS6=ChipSelect" + newline + ...
    "*			 : 100 - A/B/C/D_DBUS7=ChipSelect" + newline + ...
    "*	BIT5: ChipSelect is active high if this bit is 0" + newline + ...
    "*	BIT6 -BIT31		: Reserved");
defineOutput(SPI_ChangeCSDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
validate(SPI_ChangeCSDefinition);

%% C++ function |SPI_ToggleCS| with MATLAB name |clib.ftLib.SPI_ToggleCS|
% C++ Signature: FT_STATUS SPI_ToggleCS(FT_HANDLE handle,BOOL state)

SPI_ToggleCSDefinition = addFunction(libDef, ...
    "FT_STATUS SPI_ToggleCS(FT_HANDLE handle,BOOL state)", ...
    "MATLABName", "clib.ftLib.SPI_ToggleCS", ...
    "Description", "clib.ftLib.SPI_ToggleCS Representation of C++ function SPI_ToggleCS." + newline + ...
    "Toggles the state of the CS line", ...
    "DetailedDescription", "This content is from the external library documentation." + newline + ...
    "" + newline + ...
    "This function turns ON/OFF the chip select line associated with the channel"); % Modify help description values as needed.
defineArgument(SPI_ToggleCSDefinition, "handle", "clib.ftLib.PVOID", "input", 1, "Description", "[in] handle Handle of the channel"); % <MLTYPE> can be "clib.ftLib.PVOID", primitive type, user-defined type, or a clib.array type.
defineArgument(SPI_ToggleCSDefinition, "state", "int32", "Description", "[in] state TRUE if CS needs to be set, false otherwise");
defineOutput(SPI_ToggleCSDefinition, "RetVal", "uint32", "Description", "Returns status code of type FT_STATUS(see D2XX Programmer's Guide)");
validate(SPI_ToggleCSDefinition);

%% Validate the library definition
validate(libDef);

end
