function [methodinfo,structs,enuminfo,ThunkLibName]=libmpsse
%LIBMPSSE Create structures to define interfaces found in 'all'.

%This function was generated by loadlibrary.m parser version  on Fri Jan 17 15:58:45 2025
%perl options:'all.i -outfile=libmpsse.m -thunkfile=mpsse_thunk_pcwin64.c -header=all.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'mpsse_thunk_pcwin64');
%  void __stdcall Init_libMPSSE ( void ); 
fcns.thunkname{fcnNum}='voidvoidThunk';fcns.name{fcnNum}='Init_libMPSSE'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  void __stdcall Cleanup_libMPSSE ( void ); 
fcns.thunkname{fcnNum}='voidvoidThunk';fcns.name{fcnNum}='Cleanup_libMPSSE'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  FT_STATUS __stdcall Ver_libMPSSE ( LPDWORD libmpsse , LPDWORD libftd2xx ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrThunk';fcns.name{fcnNum}='Ver_libMPSSE'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'uint32Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_GetNumChannels ( DWORD * numChannels ); 
fcns.thunkname{fcnNum}='ulongvoidPtrThunk';fcns.name{fcnNum}='I2C_GetNumChannels'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'uint32Ptr'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_GetChannelInfo ( DWORD index , FT_DEVICE_LIST_INFO_NODE * chanInfo ); 
fcns.thunkname{fcnNum}='ulongulongvoidPtrThunk';fcns.name{fcnNum}='I2C_GetChannelInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'ulong', 's_ft_device_list_info_nodePtr'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_OpenChannel ( DWORD index , FT_HANDLE * handle ); 
fcns.thunkname{fcnNum}='ulongulongvoidPtrThunk';fcns.name{fcnNum}='I2C_OpenChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'ulong', 'voidPtrPtr'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_InitChannel ( FT_HANDLE handle , I2C_ChannelConfig * config ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrThunk';fcns.name{fcnNum}='I2C_InitChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'ChannelConfig_i2cPtr'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_CloseChannel ( FT_HANDLE handle ); 
fcns.thunkname{fcnNum}='ulongvoidPtrThunk';fcns.name{fcnNum}='I2C_CloseChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_DeviceRead ( FT_HANDLE handle , UCHAR deviceAddress , DWORD sizeToTransfer , UCHAR * buffer , LPDWORD sizeTransfered , DWORD options ); 
fcns.thunkname{fcnNum}='ulongvoidPtruint8ulongvoidPtrvoidPtrulongThunk';fcns.name{fcnNum}='I2C_DeviceRead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'uint8', 'ulong', 'uint8Ptr', 'uint32Ptr', 'ulong'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_DeviceWrite ( FT_HANDLE handle , UCHAR deviceAddress , DWORD sizeToTransfer , UCHAR * buffer , LPDWORD sizeTransfered , DWORD options ); 
fcns.thunkname{fcnNum}='ulongvoidPtruint8ulongvoidPtrvoidPtrulongThunk';fcns.name{fcnNum}='I2C_DeviceWrite'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'uint8', 'ulong', 'uint8Ptr', 'uint32Ptr', 'ulong'};fcnNum=fcnNum+1;
%  FT_STATUS I2C_GetDeviceID ( FT_HANDLE handle , UCHAR deviceAddress , UCHAR * deviceID ); 
fcns.thunkname{fcnNum}='ulongvoidPtruint8voidPtrThunk';fcns.name{fcnNum}='I2C_GetDeviceID'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'uint8', 'uint8Ptr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_GetNumChannels ( DWORD * numChannels ); 
fcns.thunkname{fcnNum}='ulongvoidPtrThunk';fcns.name{fcnNum}='SPI_GetNumChannels'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'uint32Ptr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_GetChannelInfo ( DWORD index , FT_DEVICE_LIST_INFO_NODE * chanInfo ); 
fcns.thunkname{fcnNum}='ulongulongvoidPtrThunk';fcns.name{fcnNum}='SPI_GetChannelInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'ulong', 's_ft_device_list_info_nodePtr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_OpenChannel ( DWORD index , FT_HANDLE * handle ); 
fcns.thunkname{fcnNum}='ulongulongvoidPtrThunk';fcns.name{fcnNum}='SPI_OpenChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'ulong', 'voidPtrPtr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_InitChannel ( FT_HANDLE handle , SPI_ChannelConfig * config ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrThunk';fcns.name{fcnNum}='SPI_InitChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'ChannelConfig_spiPtr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_CloseChannel ( FT_HANDLE handle ); 
fcns.thunkname{fcnNum}='ulongvoidPtrThunk';fcns.name{fcnNum}='SPI_CloseChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_IsBusy ( FT_HANDLE handle , BOOL * state ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrThunk';fcns.name{fcnNum}='SPI_IsBusy'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'int32Ptr'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_Read ( FT_HANDLE handle , UCHAR * buffer , DWORD sizeToTransfer , LPDWORD sizeTransfered , DWORD options ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrulongvoidPtrulongThunk';fcns.name{fcnNum}='SPI_Read'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', 'ulong', 'uint32Ptr', 'ulong'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_Write ( FT_HANDLE handle , UCHAR * buffer , DWORD sizeToTransfer , LPDWORD sizeTransfered , DWORD options ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrulongvoidPtrulongThunk';fcns.name{fcnNum}='SPI_Write'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', 'ulong', 'uint32Ptr', 'ulong'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_ReadWrite ( FT_HANDLE handle , UCHAR * inBuffer , UCHAR * outBuffer , DWORD sizeToTransfer , LPDWORD sizeTransferred , DWORD transferOptions ); 
fcns.thunkname{fcnNum}='ulongvoidPtrvoidPtrvoidPtrulongvoidPtrulongThunk';fcns.name{fcnNum}='SPI_ReadWrite'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', 'uint8Ptr', 'ulong', 'uint32Ptr', 'ulong'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_ChangeCS ( FT_HANDLE handle , DWORD configOptions ); 
fcns.thunkname{fcnNum}='ulongvoidPtrulongThunk';fcns.name{fcnNum}='SPI_ChangeCS'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'ulong'};fcnNum=fcnNum+1;
%  FT_STATUS SPI_ToggleCS ( FT_HANDLE handle , BOOL state ); 
fcns.thunkname{fcnNum}='ulongvoidPtrint32Thunk';fcns.name{fcnNum}='SPI_ToggleCS'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ulong'; fcns.RHS{fcnNum}={'voidPtr', 'int32'};fcnNum=fcnNum+1;
structs.s_ft_device_list_info_node.members=struct('Flags', 'ulong', 'Type', 'ulong', 'ID', 'ulong', 'LocId', 'ulong', 'SerialNumber', 'int8#16', 'Description', 'int8#64', 'ftHandle', 'voidPtr');
structs.ChannelConfig_i2c.members=struct('ClockRate', 'I2C_ClockRate_t', 'LatencyTimer', 'uint8', 'Options', 'ulong', 'Pin', 'ulong', 'currentPinState', 'uint16');
structs.ChannelContext_i2c.members=struct('handle', 'voidPtr', 'config', 'ChannelConfig_i2c', 'next', 'ChannelContext_i2cPtr');
structs.ChannelConfig_spi.members=struct('ClockRate', 'ulong', 'LatencyTimer', 'uint8', 'configOptions', 'ulong', 'Pin', 'ulong', 'currentPinState', 'uint16');
structs.ChannelContext_spi.members=struct('handle', 'voidPtr', 'config', 'ChannelConfig_spi', 'next', 'ChannelContext_spiPtr');
enuminfo.I2C_ClockRate_t=struct('I2C_CLOCK_STANDARD_MODE',100000,'I2C_CLOCK_FAST_MODE',400000,'I2C_CLOCK_FAST_MODE_PLUS',1000000,'I2C_CLOCK_HIGH_SPEED_MODE',3400000);
methodinfo=fcns;